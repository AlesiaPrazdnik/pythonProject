# s1 = {1,5,2,7,1,-7}
# print(s1) #при печати выведет без задвоенных элементов и расположит уже как захочет
# s1.add(9) #добавлние одного элемента в множество, также можно добавить кортеж
# s1.add((1,5,6,5,4,)) #добавление кортежа
# s1.update([1,2,3,4])# добавление большого кол-ва эл-тов через список и его рапсаковку
# print(s1)
# s1.pop()#удаляет случайный элемент
# s1.discard(10) #удаление элемента, если этого элемента нет - не выдаёт ошибку
# s1.remove(9)#удаление элемента, если этого элемента нет - выдаёт ошибку
# print(len(s1))
#
# s = "hello world"
# s2 = set(s) #создание множества
# print(s2) #выведет созданное множество как захочет и без повторяюзихся элементов
#
# for el in s1:
#     print(el) # поэлементный перебор
#

# tup = (1,2,3,1,1,1,1,1,2)
# fs = frozenset(tup)
# l = list(tup)
# s2 = set(tup)
# print(tup.__sizeof__()) #размер памяти задействованной
# print(fs.__sizeof__())
# print(l.__sizeof__())
# print(s2.__sizeof__())

# s1 = {1,5,2,7}
# s2 ={1,10,7,8}
# # print(s1.intersection(s2))
# # print(s1) #просто покажет пересечение
# # s1.intersection_update(s2) # изменит начальное множество
# # print(s1)
# print(s1.intersection(s2)) #персчение
# print(s1.union(s2)) #объединение
# print (s1.difference(s2)) #разность s1 - s2
# print (s2.difference(s1))#разность s2 - s1
# print(s1.symmetric_difference(s2)) #симметричная разность, без пересечений
# print(s1.isdisjoint(s2)) #если есть пересечение - False, если нет = True
# print(s1.issubset(s2)) #является ли s1 подмножеством s2 ( в s1 все элементы встречаются в s2)
# print(s1.issuperset(s2)) #d входит ли полностью s2  в s1

# a = {1,2,3}
# b = {3,4,5}
# print(a>b) #выведет False, так как b не является подмножеством a, чтоб было TRue, надо чтоб б было подмножеством а и а было больше по количеству элементов